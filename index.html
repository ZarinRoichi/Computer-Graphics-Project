<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Medieval Castle Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        /* small UI for 4 buttons */
        .ui { position:absolute; top:10px; left:10px; z-index:10; font:12px/1.2 system-ui,sans-serif; }
        .ui .row { text-align:center; margin:2px 0; }
        .ui button {
          padding:6px 10px; margin:0 2px; border-radius:8px; border:1px solid #444;
          background:#111; color:#eee; cursor:pointer;
        }
        .ui button:active { transform: translateY(1px); }
    </style>
</head>
<body>


<div class="ui">
  <div class="row"><button id="btnUp">▲ Zoom In</button></div>
  <div class="row">
    <button id="btnLeft">◄ Left</button>
    <button id="btnRight">Right ►</button>
  </div>
  <div class="row"><button id="btnDown">▼ Zoom Out</button></div>
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, -60);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
    sunLight.position.set(10, 20, 10);
    sunLight.target.position.set(0, 0, 0);
    scene.add(sunLight);
    scene.add(sunLight.target);

    // Textures
    const textureLoader = new THREE.TextureLoader();
    const stoneTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
    stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
    stoneTexture.repeat.set(4, 4);
    const woodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
    woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
    woodTexture.repeat.set(1, 1);
    const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
    groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(20, 20);

    // Materials
    const castleWallMaterial = new THREE.MeshPhongMaterial({ map: stoneTexture });
    const drawbridgeMaterial = new THREE.MeshPhongMaterial({ map: woodTexture }); // wood
    const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture });

    // Castle
    const castleGroup = new THREE.Group();
    scene.add(castleGroup);

    const wallHeight = 15;
    const wallThickness = 2;
    const halfCastleSize = 20;
    const gateWidth = 10;
    const gateHeight = 10;

    const frontSegmentWidth = (halfCastleSize * 2 - gateWidth) / 2;
    const frontWallGeom = new THREE.BoxGeometry(frontSegmentWidth, wallHeight, wallThickness);

    const frontLeftWallMesh = new THREE.Mesh(frontWallGeom, castleWallMaterial);
    frontLeftWallMesh.position.set(-(gateWidth / 2 + frontSegmentWidth / 2), wallHeight / 2, -halfCastleSize);
    castleGroup.add(frontLeftWallMesh);

    const frontRightWallMesh = new THREE.Mesh(frontWallGeom, castleWallMaterial);
    frontRightWallMesh.position.set(gateWidth / 2 + frontSegmentWidth / 2, wallHeight / 2, -halfCastleSize);
    castleGroup.add(frontRightWallMesh);

    const topSegmentHeight = wallHeight - gateHeight;
    const frontTopWallGeom = new THREE.BoxGeometry(gateWidth, topSegmentHeight, wallThickness);
    const frontTopWallMesh = new THREE.Mesh(frontTopWallGeom, castleWallMaterial);
    frontTopWallMesh.position.set(0, gateHeight + topSegmentHeight / 2, -halfCastleSize);
    castleGroup.add(frontTopWallMesh);

    const backWallGeom = new THREE.BoxGeometry(halfCastleSize * 2, wallHeight, wallThickness);
    const backWallMesh = new THREE.Mesh(backWallGeom, castleWallMaterial);
    backWallMesh.position.set(0, wallHeight / 2, halfCastleSize);
    castleGroup.add(backWallMesh);

    const sideWallGeom = new THREE.BoxGeometry(wallThickness, wallHeight, halfCastleSize * 2);
    const leftWallMesh = new THREE.Mesh(sideWallGeom, castleWallMaterial);
    leftWallMesh.position.set(-halfCastleSize, wallHeight / 2, 0);
    castleGroup.add(leftWallMesh);
    const rightWallMesh = new THREE.Mesh(sideWallGeom, castleWallMaterial);
    rightWallMesh.position.set(halfCastleSize, wallHeight / 2, 0);
    castleGroup.add(rightWallMesh);

    // Drawbridge
    const bridgeWidth = gateWidth;
    const bridgeLength = 12;
    const bridgeThickness = 0.5;
    const drawbridgeGeom = new THREE.BoxGeometry(bridgeWidth, bridgeThickness, bridgeLength);
    const drawbridgeMesh = new THREE.Mesh(drawbridgeGeom, drawbridgeMaterial);

    const drawbridgePivot = new THREE.Object3D();
    drawbridgePivot.position.set(0, 0, -halfCastleSize - wallThickness / 2);
    drawbridgeMesh.position.set(0, bridgeThickness / 2, -bridgeLength / 2);
    drawbridgePivot.add(drawbridgeMesh);
    scene.add(drawbridgePivot);

    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function toggleBridge() {
        drawbridgeRaised = !drawbridgeRaised;
        autoTimer = 0; 
    }

    renderer.domElement.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return; // only left click
        const r = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - r.left) / r.width) * 2 - 1;
        mouse.y = -((e.clientY - r.top) / r.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObject(drawbridgeMesh, true);
        if (hit.length) toggleBridge();
    });
    

    // Ground
    const groundGeom = new THREE.PlaneGeometry(500, 500);
    const groundMesh = new THREE.Mesh(groundGeom, groundMaterial);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.position.y = 0;
    scene.add(groundMesh);

    // Sky (shader)
    const skyGeom = new THREE.SphereGeometry(500, 32, 32);
    const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            topColor: { value: new THREE.Color(0x87ceeb) },
            bottomColor: { value: new THREE.Color(0xf0e68c) }
        },
        vertexShader: `
            varying float vY;
            void main() {
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vY = normalize(worldPos.xyz).y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            varying float vY;
            void main() {
                float t = (vY + 1.0) / 2.0;
                vec3 color = mix(bottomColor, topColor, clamp(t, 0.0, 1.0));
                gl_FragColor = vec4(color, 1.0);
            }
        `
    });
    const skyDome = new THREE.Mesh(skyGeom, skyMat);
    scene.add(skyDome);

    // Animation state
    let angle = Math.PI * 1.05;
    let orbitRadius = 60;     // <-- changed to let for zoom control
    const orbitSpeed = 0.2;

    let timeOfDay = 0.0;
    const dayNightSpeed = 0.2;

    let drawbridgeRaised = false;
    const raiseAngle = Math.PI / 2;
    const lowerAngle = 0;
    let drawbridgeAngle = 0;
    const drawbridgeSpeed = Math.PI / 4;

    // ADDED: auto cycle variables
    let autoTimer = 0;
    const autoPeriod = 6; // seconds

    const dayTopColor = new THREE.Color(0x87ceeb);
    const dayBottomColor = new THREE.Color(0xf0e68c);
    const nightTopColor = new THREE.Color(0x000022);
    const nightBottomColor = new THREE.Color(0x220050);

    // Spacebar -> toggle (unchanged logic but via function)
    window.addEventListener('keydown', (event) => {
        if (event.code === 'Space') toggleBridge();
    });

    /* ===== ADDED: button + keyboard (arrows) control ===== */
    let leftHeld=false, rightHeld=false, upHeld=false, downHeld=false;
    const manualOrbitSpeed = 1.0; // rad/sec extra
    const zoomSpeed = 40;         // units/sec for radius

    // Keyboard arrows
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft')  { e.preventDefault(); leftHeld  = true; }
      if (e.code === 'ArrowRight') { e.preventDefault(); rightHeld = true; }
      if (e.code === 'ArrowUp')    { e.preventDefault(); upHeld    = true; }
      if (e.code === 'ArrowDown')  { e.preventDefault(); downHeld  = true; }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft')  leftHeld  = false;
      if (e.code === 'ArrowRight') rightHeld = false;
      if (e.code === 'ArrowUp')    upHeld    = false;
      if (e.code === 'ArrowDown')  downHeld  = false;
    });

    // UI buttons (hold = continuous)
    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    function hold(btn, setTrue, setFalse){
      btn.addEventListener('mousedown', setTrue);
      btn.addEventListener('mouseup', setFalse);
      btn.addEventListener('mouseleave', setFalse);
      btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); setTrue(); }, {passive:false});
      btn.addEventListener('touchend',   (e)=>{ e.preventDefault(); setFalse(); }, {passive:false});
    }
    hold(btnUp,   ()=>{ upHeld   = true; }, ()=>{ upHeld   = false; });
    hold(btnDown, ()=>{ downHeld = true; }, ()=>{ downHeld = false; });
    hold(btnLeft, ()=>{ leftHeld = true; }, ()=>{ leftHeld = false; });
    hold(btnRight,()=>{ rightHeld= true; }, ()=>{ rightHeld= false; });
    /* ===================================================== */

    // Resize
    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

    // Animate
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        // Auto orbit + manual nudge
        angle += orbitSpeed * delta;
        if (leftHeld)  angle -= manualOrbitSpeed * delta;
        if (rightHeld) angle += manualOrbitSpeed * delta;

        // Zoom by changing orbit radius
        if (upHeld)   orbitRadius = Math.max(10,  orbitRadius - zoomSpeed * delta);
        if (downHeld) orbitRadius = Math.min(200, orbitRadius + zoomSpeed * delta);

        // Camera position
        if (angle > Math.PI * 2) angle -= Math.PI * 2;
        camera.position.x = orbitRadius * Math.sin(angle);
        camera.position.z = orbitRadius * Math.cos(angle);
        camera.lookAt(castleGroup.position);

        // Day-night sky
        timeOfDay += dayNightSpeed * delta;
        if (timeOfDay > Math.PI * 2) timeOfDay -= Math.PI * 2;
        const factor = (1 - Math.cos(timeOfDay)) / 2;
        skyMat.uniforms.topColor.value.copy(dayTopColor).lerp(nightTopColor, factor);
        skyMat.uniforms.bottomColor.value.copy(dayBottomColor).lerp(nightBottomColor, factor);
        sunLight.intensity = 0.1 + 0.9 * (1 - factor);
        ambientLight.intensity = 0.2 + 0.3 * (1 - factor);

        // --- auto toggle every autoPeriod seconds (bridge) ---
        autoTimer += delta;
        if (autoTimer >= autoPeriod) toggleBridge();

        // Drawbridge easing
        const targetAngle = drawbridgeRaised ? raiseAngle : lowerAngle;
        if (drawbridgeAngle < targetAngle) {
            drawbridgeAngle += drawbridgeSpeed * delta;
            if (drawbridgeAngle > targetAngle) drawbridgeAngle = targetAngle;
        } else if (drawbridgeAngle > targetAngle) {
            drawbridgeAngle -= drawbridgeSpeed * delta;
            if (drawbridgeAngle < targetAngle) drawbridgeAngle = targetAngle;
        }
        drawbridgePivot.rotation.x = drawbridgeAngle;

        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
